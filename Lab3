// Archivo: calcudisplay.c
// Descripción: Calculadora básica de 8 bits con resultado en display de 7 segmentos de 4 dígitos.
//              para el microcontrolador PIC16F887.

// CONFIG1
#pragma config FOSC = INTRC_NOCLKOUT// Oscillator Selection bits (INTOSCIO oscillator: I/O function on RA6/OSC2/CLKOUT pin, I/O function on RA7/OSC1/CLKIN)
#pragma config WDTE = OFF       // Watchdog Timer Enable bit (WDT disabled and can be enabled by SWDTEN bit of the WDTCON register)
#pragma config PWRTE = OFF      // Power-up Timer Enable bit (PWRT disabled)
#pragma config MCLRE = ON       // RE3/MCLR pin function select bit (RE3/MCLR pin function is MCLR)
#pragma config CP = OFF         // Code Protection bit (Program memory code protection is disabled)
#pragma config CPD = OFF        // Data Code Protection bit (Data memory code protection is disabled)
#pragma config BOREN = ON       // Brown Out Reset Selection bits (BOR enabled)
#pragma config IESO = ON        // Internal External Switchover bit (Internal/External Switchover mode is enabled)
#pragma config FCMEN = ON       // Fail-Safe Clock Monitor Enabled bit (Fail-Safe Clock Monitor is enabled)
#pragma config LVP = OFF        // Low-Voltage Programming Enable bit (RB3 pin has digital I/O, HV on MCLR must be used for programming)

// CONFIG2
#pragma config BOR4V = BOR40V     // Brown-out Reset Selection bit (Brown-out Reset set to 4.0V)
#pragma config WRT = OFF        // Flash Program Memory Self Write Enable bits (Write protection off)

#include <xc.h>

#define _XTAL_FREQ 8000000 // Frecuencia del oscilador interno (8MHz)

// --- Tabla de conversión para display de 7 segmentos (ánodo común) ---
// Segmentos: gfedcba
const unsigned char display_map[10] = {
    0b00111111, // 0
    0b00000110, // 1
    0b01011011, // 2
    0b01001111, // 3
    0b01100110, // 4
    0b01101101, // 5
    0b01111101, // 6
    0b00000111, // 7
    0b01111111, // 8
    0b01101111  // 9
};

// --- Variables para la multiplexación ---
unsigned char digito[4]; // Almacena los 4 dígitos del resultado

void separar_digitos(unsigned int numero) {
    unsigned char blank_pattern = 0b00000000; // Patrón para apagar todos los segmentos (cátodo común)

    if (numero > 9999) { // Si el número es mayor a 9999, muestra "----"
        digito[3] = 0b01000000; // Patrón de guion
        digito[2] = 0b01000000;
        digito[1] = 0b01000000;
        digito[0] = 0b01000000;
    } else {
        unsigned char d[4]; // Almacena los dígitos individuales
        d[3] = numero / 1000;
        d[2] = (numero / 100) % 10;
        d[1] = (numero / 10) % 10;
        d[0] = numero % 10;

        char leading_zero_active = 1; // Bandera para suprimir ceros a la izquierda

        for (int i = 3; i >= 0; i--) { // Itera desde el dígito más significativo (millares)
            if (leading_zero_active && d[i] == 0) {
                if (i == 0) { // Si es el dígito de las unidades y el número es 0 (ej. 0000)
                    digito[i] = display_map[0]; // Muestra '0'
                } else {
                    digito[i] = blank_pattern; // Suprime el cero (deja el dígito en blanco)
                }
            } else {
                leading_zero_active = 0; // Se encontró un dígito distinto de cero, desactiva la supresión
                digito[i] = display_map[d[i]];
            }
        }
    }
}

void main(void) {
    // --- Configuración de Puertos ---
    ANSEL = 0x00;
    ANSELH = 0x00;

    TRISA = 0x00;  // PORTA como salida (control de transistores para los dígitos)
    TRISB = 0xFF;  // PORTB como entrada (números A y B)
    TRISC = 0x00;  // PORTC no se usa
    TRISD = 0x00;  // PORTD como salida (segmentos del display)
    TRISE = 0x07;  // RE0, RE1, RE2 como entradas

    // --- Inicialización de Puertos ---
    PORTA = 0x00;
    PORTB = 0x00;
    PORTC = 0x00;
    PORTD = 0x00;
    PORTE = 0x00;
    
    // --- Configuración del Oscilador ---
    OSCCONbits.IRCF = 0b111;
    OSCCONbits.SCS = 0b10;

    // --- Variables para la lógica de entrada ---
    unsigned char numA = 0;
    unsigned char numB = 0;
    static char re2_anterior = -1;

    // --- Bucle Principal ---
    while (1) {
        // --- Lectura de Entradas ---
        char re2_actual = PORTEbits.RE2;
        if (re2_actual != re2_anterior) {
            if (re2_anterior == 0) numA = PORTB;
            else if (re2_anterior == 1) numB = PORTB;
            re2_anterior = re2_actual;
        }

        unsigned char operacion = PORTE & 0x03;

        // --- Lógica de la Calculadora ---
        unsigned int resultado = 0;
        signed int resultado_resta = 0;
        char es_negativo = 0;

        switch (operacion) {
            case 0b00: // División
                if (numB == 0) resultado = 9999; // Error
                else resultado = (unsigned int)numA / (unsigned int)numB;
                break;
            case 0b01: // Resta
                resultado_resta = (signed int)numA - (signed int)numB;
                if (resultado_resta < 0) {
                    es_negativo = 1;
                    resultado = -resultado_resta;
                } else {
                    resultado = resultado_resta;
                }
                break;
            case 0b10: // Multiplicación
                resultado = (unsigned int)numA * (unsigned int)numB;
                break;
            case 0b11: // Suma
                resultado = (unsigned int)numA + (unsigned int)numB;
                break;
        }

        // --- Preparación para mostrar en el display ---
        separar_digitos(resultado);
        
        // Si el resultado de la resta fue negativo, el primer dígito es un guión
        if (es_negativo) {
            digito[3] = 0b01000000; // Guion
        }

        // --- Multiplexación del Display ---
        // Muestra el dígito de las unidades
        PORTA = 0b00000001; // Activa el dígito 1 (unidades)
        PORTD = digito[0];
        __delay_ms(5);

        // Muestra el dígito de las decenas
        PORTA = 0b00000010; // Activa el dígito 2 (decenas)
        PORTD = digito[1];
        __delay_ms(5);

        // Muestra el dígito de las centenas
        PORTA = 0b00000100; // Activa el dígito 3 (centenas)
        PORTD = digito[2];
        __delay_ms(5);

        // Muestra el dígito de los millares
        PORTA = 0b00001000; // Activa el dígito 4 (millares)
        PORTD = digito[3];
        __delay_ms(5);
    }
    
    return;
}
